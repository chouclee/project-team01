package edu.cmu.lti.f14.project.annotator;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;

import org.apache.uima.UimaContext;
import org.apache.uima.analysis_component.JCasAnnotator_ImplBase;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.cas.FSIterator;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.cas.FSList;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.resource.ResourceInitializationException;

import util.Utils;
import edu.cmu.lti.oaqa.type.retrieval.AtomicQueryConcept;
import edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept;

import com.aliasi.chunk.Chunk;
import com.aliasi.chunk.ConfidenceChunker;
import com.aliasi.util.AbstractExternalizable;

import edu.cmu.lti.oaqa.type.input.Question;

/**
 * Use Lingpipe NER to extract bio-related terms.
 * @author kangh
 *
 */
public class NLPAnnotator extends JCasAnnotator_ImplBase {

	/**
	 * the maximum length of potential gene words
	 */
	private static final int sMAX_N_BEST_CHUNKS = 10;

	/**
	 * the handler to load the model and process given words
	 */
	private ConfidenceChunker mchunker = null;

	private static double sCONFIDENCE = 0.1;

	@Override
	/** 
	 *<p>The framework supplies this AnalysisComponent with a reference to the UimaContext that it will use,<br>
	 * for example to access configuration settings or resources. This AnalysisComponent should store a <br>
	 * reference to its the UimaContext for later use.<br>
	 * 
	 * @param context
	 *          Provides access to external resources (other than the CAS).Performs any startup tasks required by this component. The framework calls this method only once, just 
	 * after the AnalysisComponent has been instantiated. 
	 * 
	 * @throws ClassNotFoundException    Description of ClassNotFoundException found no such model
	 * @throws IOException Description of  IOException fail to visit model
	 * 
	 * @return 
	 */
	public void initialize(UimaContext context)
			throws ResourceInitializationException {
		super.initialize(context);

		try {
			mchunker = (ConfidenceChunker) AbstractExternalizable
					.readResourceObject( (String) context
							.getConfigParameterValue("GeneTagModel"));
			// chunker = (ConfidenceChunker)
			// AbstractExternalizable.readResourceObject("/neenbiogenetag");
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@Override
	/**
	 *  get content of annotation sentence and use NER gene model to classify the sentence in each annotation, 
	 *  obtain start index and end index of filtered words and
	 *  revise by subtracting the number of blanks. the gene annotation also stored the ID and words. 
	 * 
	 * @param aCas 
	 *          A JCas object provides the starting point for working with the CAS using Java Cover Classes for each  type, generated by the utility JCasGen. 
	 *
	 * @throws ClassNotFoundException   
	 *           Description of ClassNotFoundException found no such model
	 * @throws IOException 
	 *            Description of IOException fail to visit model
	 */
	public synchronized void process(JCas aCas)
			throws AnalysisEngineProcessException {
		FSIterator<Annotation> it = aCas.getAnnotationIndex(Question.type)
				.iterator();
		// while (it.hasNext()) {
		Question query = (Question) it.next();
		String originalText = query.getText();
		char[] cs = originalText.toCharArray();
		Iterator<Chunk> gene_it = mchunker.nBestChunks(cs, 0, cs.length,
				sMAX_N_BEST_CHUNKS);
		String newQuery = "";
		while (gene_it.hasNext()) {
			Chunk chunk = gene_it.next();
			double conf = Math.pow(2.0, chunk.score());
			if (conf > sCONFIDENCE) {
				int start = chunk.start();
				int end = chunk.end();
				String phrase = originalText.substring(start, end);
				newQuery += phrase + " ";
			}
		}
		System.out.println("**" + newQuery);
		AtomicQueryConcept atomicQueryConcept = new AtomicQueryConcept(aCas);
		atomicQueryConcept.setOriginalText(originalText);
		if (newQuery == " "){
			atomicQueryConcept.setText(originalText);
		}
		else{
			atomicQueryConcept.setText(newQuery);
		}
		atomicQueryConcept.addToIndexes();
		// add atomic to complex
		ComplexQueryConcept complexQueryConcept = new ComplexQueryConcept(aCas);

		// fs
		FSList fs = new FSList(aCas);
		// arraylist
		ArrayList<AtomicQueryConcept> tokenList = new ArrayList<AtomicQueryConcept>();
		tokenList.add(atomicQueryConcept);

		// from arraylist to fs Change in the Utils
		fs = Utils.fromCollectionToFSList(aCas, tokenList);
		complexQueryConcept.setOperatorArgs(Utils.fromCollectionToFSList(aCas,
				tokenList));
		complexQueryConcept.addToIndexes();
	}

}
